Index: src/geometries/Tube.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package geometries;\r\nimport primitives.*;\r\n//import primitives.Double3;\r\n\r\npublic class Tube implements Geometry {\r\n\tprivate Ray axisRay;\r\n\tprivate double radius;\r\n\t/**\r\n\t * Constructor\r\n\t * @param a\r\n\t * @param r\r\n\t */\r\n\tpublic Tube(Ray a, double r)\r\n\t{\r\n\t\taxisRay = new Ray(a.getP0(), a.getDir());\r\n\t\tradius = r;\r\n\t}\r\n\t/**\r\n\t * Calculates the normalized normal to the tube\r\n\t * @return\r\n\t */\r\n\tpublic Vector getNormal(Point p)\r\n\t{\r\n\t\tVector v = p.subtract(axisRay.getP0());\r\n\t\tdouble ans = axisRay.getDir().dotProduct(v);\r\n\t\tif (ans==0)\r\n\t\t{\r\n\t\t\tthrow new IllegalArgumentException(\"The point is in front of the head of the ray\");\r\n\t\t}\r\n\t\tdouble t = axisRay.getDir().dotProduct(p.subtract(axisRay.getP0()));\r\n\t\tPoint o = axisRay.getP0().add(axisRay.getDir().scale(t));\r\n\t\tVector n = p.subtract(o).normalize();\r\n\t\treturn n;\r\n\t}\r\n\t\r\n\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/geometries/Tube.java b/src/geometries/Tube.java
--- a/src/geometries/Tube.java	(revision ea628a76f7db129a3869b57256a7057ace2dc7ed)
+++ b/src/geometries/Tube.java	(date 1648394339211)
@@ -32,6 +32,6 @@
 		Vector n = p.subtract(o).normalize();
 		return n;
 	}
-	
+
 
 }
Index: src/geometries/Sphere.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package geometries;\r\nimport java.util.List;\r\n\r\nimport primitives.*;\r\n/**\r\n * Sphere (point and radius)\r\n *\r\n */\r\npublic class Sphere implements Geometry {\r\n\tprivate Point center;\r\n\tprivate double radius;\r\n\t/**\r\n\t * Constructor\r\n\t * @param p1\r\n\t * @param r\r\n\t */\r\n\tpublic Sphere (Point p1, double r)\r\n\t{\r\n\t\tcenter = p1;\r\n\t\tradius = r;\r\n\t}\r\n\t/**\r\n\t * Calculates the normalized normal to the sphere\r\n\t * @return\r\n\t */\r\n\tpublic Vector getNormal(Point p)\r\n\t{\r\n\t\tVector n = p.subtract(center).normalize();\r\n\t\treturn n;\r\n\t}\r\n\tpublic List<Point> findIntsersections(Ray ray)\r\n\t{\r\n\t\t\r\n\t}\r\n\t\r\n}\r\n\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/geometries/Sphere.java b/src/geometries/Sphere.java
--- a/src/geometries/Sphere.java	(revision ea628a76f7db129a3869b57256a7057ace2dc7ed)
+++ b/src/geometries/Sphere.java	(date 1648468391039)
@@ -1,6 +1,4 @@
 package geometries;
-import java.util.List;
-
 import primitives.*;
 /**
  * Sphere (point and radius)
@@ -28,10 +26,6 @@
 		Vector n = p.subtract(center).normalize();
 		return n;
 	}
-	public List<Point> findIntsersections(Ray ray)
-	{
-		
-	}
-	
+
 }
 
Index: src/geometries/Triangle.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package geometries;\r\nimport primitives.*;\r\n\r\npublic class Triangle extends Polygon {\r\n\t/**\r\n\t * Constructor\r\n\t * @param p1\r\n\t * @param p2\r\n\t * @param p3\r\n\t */\r\n\tpublic Triangle(Point p1, Point p2, Point p3)\r\n\t{\r\n\t\tsuper(p1, p2, p3);\r\n\t}\r\n\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/geometries/Triangle.java b/src/geometries/Triangle.java
--- a/src/geometries/Triangle.java	(revision ea628a76f7db129a3869b57256a7057ace2dc7ed)
+++ b/src/geometries/Triangle.java	(date 1648406851257)
@@ -12,5 +12,9 @@
 	{
 		super(p1, p2, p3);
 	}
+	public Vector getNormal(Point point)
+	{
+		return super.getNormal(point);
+	}
 
 }
Index: src/primitives/Vector.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package primitives;\r\n/**\r\n * Vector - An object with length and direction\r\n *\r\n */\r\npublic class Vector extends Point {\r\n\t/**\r\n\t * Constructor\r\n\t * @param d1\r\n\t * @param d2\r\n\t * @param d3\r\n\t */\r\n\tpublic Vector(double d1, double d2, double d3)\r\n\t{\r\n\t\tsuper(d1, d2, d3);\r\n\t\tif(Double3.ZERO.equals(xyz))\r\n\t\t{\r\n\t\t\tthrow new IllegalArgumentException(\"Vector zero is prohibited\");\r\n\t\t}\r\n\t}\r\n\t/**\r\n\t * Constructor\r\n\t * @param d\r\n\t */\r\n\tpublic Vector(Double3 d)\r\n\t{\r\n\t\tsuper(d);\r\n\t\tif(Double3.ZERO.equals(xyz))\r\n\t\t{\r\n\t\t\tthrow new IllegalArgumentException(\"Vector zero is prohibited\");\r\n\t\t}\r\n\t}\r\n\tpublic Double3 getXyz() {\r\n\t\treturn xyz;\r\n\t}\r\n\t@Override\r\n\tpublic boolean equals(Object obj) {\r\n\t\treturn super.equals(obj);\r\n\t}\r\n\t@Override\r\n\tpublic String toString() {\r\n\t\treturn super.toString();\r\n\t}\r\n\t\r\n\t@Override\r\n\tpublic Vector add(Vector v)\r\n\t{\r\n\t\tVector ans = new Vector(this.xyz.add(v.xyz));\r\n\t\treturn ans;\r\n\t}\r\n\t/**\r\n\t * Vector multiplication by a number\r\n\t * @param scalar\r\n\t * @return\r\n\t */\r\n\tpublic Vector scale(double scalar)\r\n\t{\r\n\t\ttry\r\n\t\t{\r\n\t\t\tVector ans = new Vector(this.xyz.scale(scalar));\r\n\t\t\treturn ans;\r\n\t\t}\r\n\t\tcatch(IllegalArgumentException ex)\r\n\t\t{\r\n\t\t\tthrow new IllegalArgumentException(ex.getMessage());\r\n\t\t}\r\n\t}\r\n\t/**\r\n\t * Scalar product\r\n\t * @param v\r\n\t * @return\r\n\t */\r\n\tpublic double dotProduct(Vector v)\r\n\t{\r\n\t\tDouble3 temp = new Double3(this.xyz.product(v.xyz).d1, this.xyz.product(v.xyz).d2, this.xyz.product(v.xyz).d3);\r\n\t\treturn (temp.d1 + temp.d2 + temp.d3);\r\n\t}\r\n\t/**\r\n\t * Vector multiplication \r\n\t * @param v\r\n\t * @return\r\n\t */\r\n\tpublic Vector crossProduct(Vector v)\r\n\t{\r\n\t\tVector ans = new Vector(xyz.d2*v.xyz.d3 - xyz.d3*v.xyz.d2,\r\n\t\t\t\txyz.d3*v.xyz.d1 - xyz.d1*v.xyz.d3, xyz.d1*v.xyz.d2 - xyz.d2*v.xyz.d1);\r\n\t\tif(Double3.ZERO.equals(ans.xyz))\r\n\t\t{\r\n\t\t\tthrow new IllegalArgumentException(\"All the point are in the same line\");\r\n\t\t}\r\n\t\treturn ans;\r\n\t}\r\n\t/**\r\n\t * Vector length squared\r\n\t * @return\r\n\t */\r\n\tpublic double lengthSquared()\r\n\t{\r\n\t\treturn this.dotProduct(this);\r\n\t}\r\n\t/**\r\n\t * Vector length\r\n\t * @return\r\n\t */\r\n\tpublic double length()\r\n\t{\r\n\t\treturn Math.sqrt(this.lengthSquared());\r\n\t}\r\n\t/**\r\n\t * A normalization operation that returns a new vector normalized in the same direction as the original vector\r\n\t * @return\r\n\t */\r\n\tpublic Vector normalize()\r\n\t{\r\n\t\tdouble temp = 1/this.length();\r\n\t\tVector ans = this.scale(temp);\r\n\t\treturn ans;\r\n\t}\r\n\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/primitives/Vector.java b/src/primitives/Vector.java
--- a/src/primitives/Vector.java	(revision ea628a76f7db129a3869b57256a7057ace2dc7ed)
+++ b/src/primitives/Vector.java	(date 1648394339249)
@@ -65,6 +65,7 @@
 			throw new IllegalArgumentException(ex.getMessage());
 		}
 	}
+	
 	/**
 	 * Scalar product
 	 * @param v
Index: src/unittests/VectorTests.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>/**\r\n * \r\n */\r\npackage unittests;\r\n\r\nimport static java.lang.System.out;\r\nimport static org.junit.jupiter.api.Assertions.*;\r\nimport static primitives.Util.isZero;\r\n\r\nimport org.junit.jupiter.api.Test;\r\n\r\nimport primitives.*;\r\nimport static primitives.Util.*;\r\n\r\n\r\n\r\n/**\r\n * Unit tests for primitives.Vector class\r\n * @author Shuva\r\n *\r\n */\r\nclass VectorTests {\r\n\r\n\t/**\r\n\t * Test method for {@link primitives.Vector#add(primitives.Vector)}.\r\n\t */\r\n\t@Test\r\n\tvoid testAddVector() {\r\n\t    // ============ Equivalence Partitions Tests ==============\r\n\t\tVector v1 = new Vector(1,2,3);\r\n\t\tVector v2 = new Vector(4,5,6);\r\n\t\tVector v3 = new Vector(5,7,9);\r\n\t    // TC01: Test that the result of add is proper\r\n\t\tassertEquals(v3, v1.add(v2), \"ERROR: add() does not work correctly\");\r\n\t}\r\n\r\n\t/**\r\n\t * Test method for {@link primitives.Vector#scale(double)}.\r\n\t */\r\n\t@Test\r\n\tvoid testScale() {\r\n\t    // ============ Equivalence Partitions Tests ==============\r\n\t\tVector v1 = new Vector(1,2,3);\r\n\t\tVector v2 = new Vector(3,6,9);\r\n\t    // TC01: Test that the result of scale is proper\r\n\t\tassertEquals(v2, v1.scale(3), \"ERROR: scale() does not work correctly\");\r\n     }\r\n\r\n\t/**\r\n\t * Test method for {@link primitives.Vector#dotProduct(primitives.Vector)}.\r\n\t */\r\n\t@Test\r\n\tvoid testDotProduct() {\r\n\t\tVector v1 = new Vector(1, 2, 3);\r\n\t    // ============ Equivalence Partitions Tests ==============\r\n\t    Vector v3 = new Vector(0, 3, -2);\r\n\t    Vector v2 = new Vector(-2, -4, -6);\r\n\t    // TC01: Test that the result of dot-product is proper\r\n\t\tassertTrue(isZero(v1.dotProduct(v2) + 28), \"ERROR: dotProduct() wrong value\");\r\n        // =============== Boundary Values Tests ==================\r\n        // TC11: test zero vector from dot-product of co-lined vectors\r\n\t\tassertTrue(isZero(v1.dotProduct(v3)), \"ERROR: dotProduct() for orthogonal vectors is not zero\");\r\n\t}\r\n\r\n\t/**\r\n\t * \r\n\t * Test method for {@link primitives.Vector#crossProduct(primitives.Vector)}.\r\n\t */\r\n\t@Test\r\n\tvoid testCrossProduct() {\r\n        Vector v1 = new Vector(1, 2, 3);\r\n\r\n        // ============ Equivalence Partitions Tests ==============\r\n        Vector v2 = new Vector(0, 3, -2);\r\n        Vector vr = v1.crossProduct(v2);\r\n\r\n        // TC01: Test that length of cross-product is proper (orthogonal vectors taken for simplicity)\r\n        assertEquals( v1.length() * v2.length(), vr.length(), 0.00001,\"crossProduct() wrong result length\");\r\n\r\n        // TC02: Test cross-product result orthogonality to its operands\r\n        assertTrue(isZero(vr.dotProduct(v1)),\"crossProduct() result is not orthogonal to 1st operand\");\r\n        assertTrue(isZero(vr.dotProduct(v2)),\"crossProduct() result is not orthogonal to 2nd operand\");\r\n\r\n        // =============== Boundary Values Tests ==================\r\n        // TC11: test zero vector from cross-productof co-lined vectors\r\n        Vector v3 = new Vector(-2, -4, -6);\r\n        assertThrows(IllegalArgumentException.class,\r\n        \t\t () -> v1.crossProduct(v3),\"crossProduct() for parallel vectors does not throw an exception\");\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Test method for {@link primitives.Vector#lengthSquared()}.\r\n\t */\r\n\t@Test\r\n\tvoid testLengthSquared() {\r\n\t    // ============ Equivalence Partitions Tests ==============\r\n\t\tVector v1 = new Vector(1, 2, 3);\r\n\t    // TC01: Test that the result of length squared is proper\r\n\t\tassertEquals(14,v1.lengthSquared(),\"ERROR: lengthSquared() wrong value\");\r\n\t\t\r\n\t}\r\n\r\n\t/**\r\n\t * Test method for {@link primitives.Vector#length()}.\r\n\t */\r\n\t@Test\r\n\tvoid testLength() {\r\n\t    // ============ Equivalence Partitions Tests ==============\r\n\t\tVector v1 = new Vector(0, 3, 4);\r\n\t    // TC01: Test that the result of length is proper\r\n\t\tassertEquals(5,v1.length(),\"ERROR: length() wrong value\");\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Test method for {@link primitives.Vector#normalize()}.\r\n\t */\r\n\t@Test\r\n\tvoid testNormalize() {\r\n\t\tVector v = new Vector(1, 2, 3);\r\n\t\tVector u = v.normalize();\r\n\t    // ============ Equivalence Partitions Tests ==============\r\n\t\t//TC01: Test that length length of normalized result is 1\r\n\t\tassertEquals(1,u.length(),\"ERROR: the normalized vector is not a unit vector\");\r\n\t\t//TC02:Test if the normalized vector is not parallel to the original one\r\n\t\tassertThrows(IllegalArgumentException.class,() ->v.crossProduct(u) ,\"ERROR: the normalized vector is not parallel to the original one\");\r\n\t\t//TC03:Test if the normalized vector is opposite to the original one\r\n        assertTrue(v.dotProduct(u) > 0,\"ERROR: the normalized vector is opposite to the original one\");\t\r\n\t}\r\n\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/unittests/VectorTests.java b/src/unittests/VectorTests.java
--- a/src/unittests/VectorTests.java	(revision ea628a76f7db129a3869b57256a7057ace2dc7ed)
+++ b/src/unittests/VectorTests.java	(date 1648394339256)
@@ -84,8 +84,7 @@
         // =============== Boundary Values Tests ==================
         // TC11: test zero vector from cross-productof co-lined vectors
         Vector v3 = new Vector(-2, -4, -6);
-        assertThrows(IllegalArgumentException.class,
-        		 () -> v1.crossProduct(v3),"crossProduct() for parallel vectors does not throw an exception");
+        assertThrows(IllegalArgumentException.class, () -> v1.crossProduct(v3),"crossProduct() for parallel vectors does not throw an exception");
 
 	}
 
@@ -112,12 +111,12 @@
 		assertEquals(5,v1.length(),"ERROR: length() wrong value");
 
 	}
-
+ 
 	/**
 	 * Test method for {@link primitives.Vector#normalize()}.
 	 */
 	@Test
-	void testNormalize() {
+	void testNormalize() { 
 		Vector v = new Vector(1, 2, 3);
 		Vector u = v.normalize();
 	    // ============ Equivalence Partitions Tests ==============
Index: src/primitives/Point.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package primitives;\r\n\r\nimport java.util.Objects;\r\n/**\r\n *  point- 3 coordinates\r\n *\r\n */\r\npublic class Point {\r\n\tfinal Double3 xyz;\r\n\t/**\r\n\t * Constructor\r\n\t * @param d1\r\n\t * @param d2\r\n\t * @param d3\r\n\t */\r\n\tpublic Point(double d1, double d2, double d3)\r\n\t{\r\n\t\txyz = new Double3(d1, d2, d3);\r\n\t}\r\n\t/**\r\n\t * Constructor\r\n\t * @param d\r\n\t */\r\n\tpublic Point(Double3 d)\r\n\t{\r\n\t\txyz = new Double3(d.d1, d.d2, d.d3);\r\n\t}\r\n\t@Override\r\n\tpublic boolean equals(Object obj) {\r\n\t\tif (this == obj) return true;\r\n\t\tif (obj == null) return false;\r\n\t\tif (!(obj instanceof Point)) return false;\r\n\t\tPoint other = (Point) obj;\r\n\t\treturn this.xyz.equals(other.xyz);\r\n\t}\r\n\t@Override\r\n\tpublic String toString() {\r\n\t\treturn \"xyz = \" + xyz.toString();\r\n\t}\r\n\t/**\r\n\t * Subtraction \r\n\t * @param p\r\n\t * @return\r\n\t */\r\n\tpublic Vector subtract(Point p)\r\n\t{\r\n\t\tVector ans = new Vector(this.xyz.subtract(p.xyz));\r\n\t\treturn ans;\r\n\t}\r\n\t/**\r\n\t * add vector to the point\r\n\t * @param v\r\n\t * @return\r\n\t */\r\n\tpublic Point add(Vector v)\r\n\t{\r\n\t\tPoint ans = new Point(this.xyz.add(v.xyz));\r\n\t\treturn ans;\r\n\t}\r\n\t/**\r\n\t * Distance between two points squared\r\n\t * @param p\r\n\t * @return\r\n\t */\r\n\tpublic double distanceSquared(Point p)\r\n\t{\r\n\t\treturn (xyz.d1-p.xyz.d1)*(xyz.d1-p.xyz.d1)+(xyz.d2-p.xyz.d2)*(xyz.d2-p.xyz.d2)+(xyz.d3-p.xyz.d3)*(xyz.d3-p.xyz.d3);\r\n\t}\r\n\t/**\r\n\t * Distance between two points\r\n\t * @param p\r\n\t * @return\r\n\t */\r\n\tpublic double distance(Point p)\r\n\t{\r\n\t\tdouble ans = Math.sqrt(distanceSquared(p));\r\n\t\treturn ans;\r\n\t}\r\n\r\n\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/primitives/Point.java b/src/primitives/Point.java
--- a/src/primitives/Point.java	(revision ea628a76f7db129a3869b57256a7057ace2dc7ed)
+++ b/src/primitives/Point.java	(date 1648396837409)
@@ -76,6 +76,14 @@
 		double ans = Math.sqrt(distanceSquared(p));
 		return ans;
 	}
-
+	public double getX() {
+		return xyz.d1;
+	}
+	public double getY() {
+		return xyz.d2;
+	}
+	public double getZ() {
+		return xyz.d3;
+	}
 
 }
Index: src/unittests/geometries/CylinderTests.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>/**\r\n * \r\n */\r\npackage unittests.geometries;\r\n\r\nimport static org.junit.jupiter.api.Assertions.*;\r\n\r\nimport org.junit.jupiter.api.Test;\r\n\r\n/**\r\n * Unit tests for geometries.Cylinder class\r\n * @author Shuva\r\n *\r\n */\r\nclass CylinderTests {\r\n\r\n\t/**\t\r\n\t * Test method for {@link geometries.Cylinder#getNormal(primitives.Point)}.\r\n\t */\r\n\t@Test\r\n\tvoid testGetNormal() {\r\n\r\n\t}\r\n\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/unittests/geometries/CylinderTests.java b/src/unittests/geometries/CylinderTests.java
--- a/src/unittests/geometries/CylinderTests.java	(revision ea628a76f7db129a3869b57256a7057ace2dc7ed)
+++ b/src/unittests/geometries/CylinderTests.java	(date 1648394339225)
@@ -1,5 +1,5 @@
 /**
- * 
+ *
  */
 package unittests.geometries;
 
@@ -14,7 +14,7 @@
  */
 class CylinderTests {
 
-	/**	
+	/**
 	 * Test method for {@link geometries.Cylinder#getNormal(primitives.Point)}.
 	 */
 	@Test
Index: src/unittests/geometries/PlaneTests.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>/**\r\n * \r\n */\r\npackage unittests.geometries;\r\n\r\nimport static org.junit.jupiter.api.Assertions.*;\r\nimport primitives.*;\r\n\r\nimport org.junit.jupiter.api.Test;\r\n\r\nimport geometries.Plane;\r\nimport geometries.Polygon;\r\nimport primitives.Point;\r\nimport primitives.Vector;\r\n\r\n/**\r\n * Unit tests for geometries.Plane class\r\n * @a uthor Shuva\r\n *\r\n */\r\nclass PlaneTests {\r\n\t/**\r\n\t * Test method for {@link geometries.Plane#Plane(primitives.Point)}.\r\n\t */\r\n\t@Test\r\n\tpublic void testConstructor()\r\n\t{\r\n\t\t// =============== Boundary Values Tests ==================\r\n\t\t\r\n        // TC10: The first 2 points coalesce\r\n\t\tassertThrows(IllegalArgumentException.class, //\r\n\t\t\t\t() -> new Plane(new Point(0,0,0), new Point(0,0,0), new Point(1,0,0)), //\r\n\t\t\t\t\"Constructed a plane with wrong values - 2 first points are identical\");\r\n\t\t\r\n        // TC11: All 3 points are on the same line\r\n\t\tassertThrows(IllegalArgumentException.class, //\r\n\t\t\t\t() -> new Plane(new Point(1,0,0), new Point(2,0,0), new Point(4,0,0)), //\r\n\t\t\t\t\"Constructed a plane with wrong values - 3 points are on the same line\");\r\n\t}\r\n\r\n\t/**\r\n\t * Test method for {@link geometries.Plane#getNormal(primitives.Point)}.32\r\n\t */\r\n\t@Test\r\n\tvoid testGetNormal() {\r\n\t\t // ============ Equivalence Partitions Tests ==============\r\n\t\t\r\n\t\tPlane p = new Plane(new Point(0,0,0), new Point(1,0,0), new Point(0,1,0));\r\n\t\tVector n1 = new Vector(0,0,1);\r\n\t\tVector n2 = new Vector(0,0,-1);\r\n\t\t// TC01: Test that the result of getNormal is proper\r\n\t\tassertTrue(p.getNormal(new Point(0,0,0)).equals(n1) || p.getNormal(new Point(0,0,0)).equals(n2), \"Bad normal tp plane\");\r\n\t\t////////////////assertEquals(n, p.getNormal(new Point(0,0,0)), \"Bad normal tp plane\");/////////////////////////////////////////\r\n\t\t\r\n\t\t// TC02: Test that the length of the normal is 1\r\n\t\tassertEquals(1, p.getNormal(new Point(0,0,0)).length(), \"The length of the normal is not 1\");\r\n\t}\r\n\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/unittests/geometries/PlaneTests.java b/src/unittests/geometries/PlaneTests.java
--- a/src/unittests/geometries/PlaneTests.java	(revision ea628a76f7db129a3869b57256a7057ace2dc7ed)
+++ b/src/unittests/geometries/PlaneTests.java	(date 1648468390141)
@@ -1,5 +1,5 @@
 /**
- * 
+ *
  */
 package unittests.geometries;
 
@@ -26,13 +26,13 @@
 	public void testConstructor()
 	{
 		// =============== Boundary Values Tests ==================
-		
-        // TC10: The first 2 points coalesce
+
+		// TC10: The first 2 points coalesce
 		assertThrows(IllegalArgumentException.class, //
 				() -> new Plane(new Point(0,0,0), new Point(0,0,0), new Point(1,0,0)), //
 				"Constructed a plane with wrong values - 2 first points are identical");
-		
-        // TC11: All 3 points are on the same line
+
+		// TC11: All 3 points are on the same line
 		assertThrows(IllegalArgumentException.class, //
 				() -> new Plane(new Point(1,0,0), new Point(2,0,0), new Point(4,0,0)), //
 				"Constructed a plane with wrong values - 3 points are on the same line");
@@ -43,15 +43,15 @@
 	 */
 	@Test
 	void testGetNormal() {
-		 // ============ Equivalence Partitions Tests ==============
-		
+		// ============ Equivalence Partitions Tests ==============
+
 		Plane p = new Plane(new Point(0,0,0), new Point(1,0,0), new Point(0,1,0));
 		Vector n1 = new Vector(0,0,1);
 		Vector n2 = new Vector(0,0,-1);
 		// TC01: Test that the result of getNormal is proper
 		assertTrue(p.getNormal(new Point(0,0,0)).equals(n1) || p.getNormal(new Point(0,0,0)).equals(n2), "Bad normal tp plane");
 		////////////////assertEquals(n, p.getNormal(new Point(0,0,0)), "Bad normal tp plane");/////////////////////////////////////////
-		
+
 		// TC02: Test that the length of the normal is 1
 		assertEquals(1, p.getNormal(new Point(0,0,0)).length(), "The length of the normal is not 1");
 	}
Index: src/primitives/Double3.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>\r\npackage primitives;\r\n\r\nimport static primitives.Util.*;\r\n\r\n/**\r\n * This class will serve all primitive classes based on three numbers\r\n * \r\n */\r\npublic class Double3 {\r\n\tfinal double d1;\r\n\tfinal double d2;\r\n\tfinal double d3;\r\n\r\n\t/**\r\n\t * Zero triad (0,0,0)\r\n\t */\r\n\tstatic final Double3 ZERO = new Double3(0, 0, 0);\r\n\r\n\t/**\r\n\t * Constructor to initialize Double3 based object with its three number values\r\n\t * \r\n\t * @param d1 first number value\r\n\t * @param d2 second number value\r\n\t * @param d3 third number value\r\n\t */\r\n\tprotected Double3(double d1, double d2, double d3) {\r\n\t\tthis.d1 = d1;\r\n\t\tthis.d2 = d2;\r\n\t\tthis.d3 = d3;\r\n\t}\r\n\r\n\t@Override\r\n\tpublic boolean equals(Object obj) {\r\n\t\tif (this == obj)\r\n\t\t\treturn true;\r\n\t\tif (obj == null)\r\n\t\t\treturn false;\r\n\t\tif (!(obj instanceof Double3))\r\n\t\t\treturn false;\r\n\t\tDouble3 other = (Double3) obj;\r\n\t\treturn isZero(d1 - other.d1) && isZero(d2 - other.d2) && isZero(d3 - other.d3);\r\n\t}\r\n\r\n\t@Override\r\n\tpublic int hashCode() {\r\n\t\treturn (int) Math.round(d1 + d2 + d3);\r\n\t}\r\n\r\n\t@Override\r\n\tpublic String toString() {\r\n\t\treturn \"(\" + d1 + \",\" + d2 + \",\" + d3 + \")\";\r\n\t}\r\n\r\n\t/**\r\n\t * Sum two floating point triads into a new triad where each couple of numbers\r\n\t * is summarized\r\n\t * \r\n\t * @param rhs right handle side operand for addition\r\n\t * @return result of add\r\n\t */\r\n\tDouble3 add(Double3 rhs) {\r\n\t\treturn new Double3(d1 + rhs.d1, d2 + rhs.d2, d3 + rhs.d3);\r\n\t}\r\n\r\n\t/**\r\n\t * Subtract two floating point triads into a new triad where each couple of\r\n\t * numbers is subtracted\r\n\t * \r\n\t * @param rhs right handle side operand for addition\r\n\t * @return result of add\r\n\t */\r\n\tDouble3 subtract(Double3 rhs) {\r\n\t\treturn new Double3(d1 - rhs.d1, d2 - rhs.d2, d3 - rhs.d3);\r\n\t}\r\n\r\n\t/**\r\n\t * Scale (multiply) floating point triad by a number into a new triad where each\r\n\t * number is multiplied by the number\r\n\t * \r\n\t * @param rhs right handle side operand for scaling\r\n\t * @return result of scale\r\n\t */\r\n\tDouble3 scale(double rhs) {\r\n\t\treturn new Double3(d1 * rhs, d2 * rhs, d3 * rhs);\r\n\t}\r\n\r\n\t/**\r\n\t * Reduce (divide) floating point triad by a number into a new triad where each\r\n\t * number is divided by the number\r\n\t * \r\n\t * @param rhs right handle side operand for reducing\r\n\t * @return result of scale\r\n\t */\r\n\tDouble3 reduce(double rhs) {\r\n\t\treturn new Double3(d1 / rhs, d2 / rhs, d3 / rhs);\r\n\t}\r\n\r\n\t/**\r\n\t * Product two floating point triads into a new triad where each couple of\r\n\t * numbers is multiplied\r\n\t * \r\n\t * @param rhs right handle side operand for product\r\n\t * @return result of product\r\n\t */\r\n\tDouble3 product(Double3 rhs) {\r\n\t\treturn new Double3(d1 * rhs.d1, d2 * rhs.d2, d3 * rhs.d3);\r\n\t}\r\n\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/primitives/Double3.java b/src/primitives/Double3.java
--- a/src/primitives/Double3.java	(revision ea628a76f7db129a3869b57256a7057ace2dc7ed)
+++ b/src/primitives/Double3.java	(date 1648394339260)
@@ -11,7 +11,7 @@
 	final double d1;
 	final double d2;
 	final double d3;
-
+ 
 	/**
 	 * Zero triad (0,0,0)
 	 */
Index: src/unittests/geometries/PolygonTests.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>/**\r\n * \r\n */\r\npackage unittests.geometries;\r\n\r\nimport static org.junit.jupiter.api.Assertions.*;\r\nimport org.junit.jupiter.api.Test;\r\n\r\nimport geometries.*;\r\nimport primitives.*;\r\n\r\n/**\r\n * Testing Polygons\r\n * \r\n * @author Dan\r\n *\r\n */\r\npublic class PolygonTests {\r\n\r\n\t/**\r\n\t * Test method for {@link geometries.Polygon#Polygon(primitives.Point...)}.\r\n\t */\r\n\t@Test\r\n\tpublic void testConstructor() {\r\n\t\t// ============ Equivalence Partitions Tests ==============\r\n\r\n\t\t// TC01: Correct concave quadrangular with vertices in correct order\r\n\t\ttry {\r\n\t\t\tnew Polygon(new Point(0, 0, 1), new Point(1, 0, 0), new Point(0, 1, 0), new Point(-1, 1, 1));\r\n\t\t} catch (IllegalArgumentException e) {\r\n\t\t\tfail(\"Failed constructing a correct polygon\");\r\n\t\t}\r\n\r\n\t\t// TC02: Wrong vertices order\r\n\t\tassertThrows(IllegalArgumentException.class, //\r\n\t\t\t\t() -> new Polygon(new Point(0, 0, 1), new Point(0, 1, 0), new Point(1, 0, 0), new Point(-1, 1, 1)), //\r\n\t\t\t\t\"Constructed a polygon with wrong order of vertices\");\r\n\r\n\t\t// TC03: Not in the same plane\r\n\t\tassertThrows(IllegalArgumentException.class, //\r\n\t\t\t\t() -> new Polygon(new Point(0, 0, 1), new Point(1, 0, 0), new Point(0, 1, 0), new Point(0, 2, 2)), //\r\n\t\t\t\t\"Constructed a polygon with vertices that are not in the same plane\");\r\n\r\n\t\t// TC04: Concave quadrangular\r\n\t\tassertThrows(IllegalArgumentException.class, //\r\n\t\t\t\t() -> new Polygon(new Point(0, 0, 1), new Point(1, 0, 0), new Point(0, 1, 0),\r\n\t\t\t\t\t\tnew Point(0.5, 0.25, 0.5)), //\r\n\t\t\t\t\"Constructed a concave polygon\");\r\n\r\n\t\t// =============== Boundary Values Tests ==================\r\n\r\n\t\t// TC10: Vertex on a side of a quadrangular\r\n\t\tassertThrows(IllegalArgumentException.class, //\r\n\t\t\t\t() -> new Polygon(new Point(0, 0, 1), new Point(1, 0, 0), new Point(0, 1, 0), new Point(0, 0.5, 0.5)),\r\n\t\t\t\t\"Constructed a polygon with vertix on a side\");\r\n\r\n\t\t// TC11: Last point = first point\r\n\t\tassertThrows(IllegalArgumentException.class, //\r\n\t\t\t\t() -> new Polygon(new Point(0, 0, 1), new Point(1, 0, 0), new Point(0, 1, 0), new Point(0, 0, 1)),\r\n\t\t\t\t\"Constructed a polygon with vertice on a side\");\r\n\r\n\t\t// TC12: Co-located points\r\n\t\tassertThrows(IllegalArgumentException.class, //\r\n\t\t\t\t() -> new Polygon(new Point(0, 0, 1), new Point(1, 0, 0), new Point(0, 1, 0), new Point(0, 1, 0)),\r\n\t\t\t\t\"Constructed a polygon with vertice on a side\");\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Test method for {@link geometries.Polygon#getNormal(primitives.Point)}.\r\n\t */\r\n\t@Test\r\n\tpublic void testGetNormal() {\r\n\t\t// ============ Equivalence Partitions Tests ==============\r\n\t\t// TC01: There is a simple single test here\r\n\t\tPolygon pl = new Polygon(new Point(0, 0, 1), new Point(1, 0, 0), new Point(0, 1, 0), new Point(-1, 1, 1));\r\n\t\tdouble sqrt3 = Math.sqrt(1d / 3);\r\n\t\tassertEquals(new Vector(sqrt3, sqrt3, sqrt3), pl.getNormal(new Point(0, 0, 1)), \"Bad normal to trinagle\");\r\n\t}\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/unittests/geometries/PolygonTests.java b/src/unittests/geometries/PolygonTests.java
--- a/src/unittests/geometries/PolygonTests.java	(revision ea628a76f7db129a3869b57256a7057ace2dc7ed)
+++ b/src/unittests/geometries/PolygonTests.java	(date 1648394339268)
@@ -1,5 +1,5 @@
 /**
- * 
+ *
  */
 package unittests.geometries;
 
@@ -11,7 +11,7 @@
 
 /**
  * Testing Polygons
- * 
+ *
  * @author Dan
  *
  */
Index: src/unittests/geometries/SphereTests.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>/**\r\n * \r\n */\r\npackage unittests.geometries;\r\nimport geometries.Sphere;\r\nimport primitives.Point;\r\nimport primitives.Ray;\r\nimport primitives.Vector;\r\n\r\nimport static org.junit.jupiter.api.Assertions.*;\r\n\r\nimport java.util.List;\r\n\r\nimport org.junit.jupiter.api.Test;\r\n\r\n/**\r\n * Unit tests for geometries.Sphere class\r\n * @author Shuva\r\n *\r\n */\r\nclass SphereTests {\r\n\r\n\t/**\r\n\t * Test method for {@link geometries.Sphere#getNormal(primitives.Point)}.\r\n\t */\r\n\t@Test\r\n\tvoid testGetNormal() {\r\n\t\t // ============ Equivalence Partitions Tests ==============\r\n\t\tSphere s = new Sphere(new Point(0,0,0), 1);\r\n\t\tVector n = new Vector(1,0,0);\r\n\t\t// TC01: Test that the result of getNormal is proper\r\n\t\tassertEquals(n, s.getNormal(new Point(1,0,0)), \"Bad normal to sphere\");\r\n\t}\r\n\t/**\r\n     * Test method for {@link geometries.Sphere#findIntersections(primitives.Ray)}.\r\n     */\r\n    @Test\r\n    public void testFindIntersections() {\r\n        Sphere sphere = new Sphere(new Point (1, 0, 0), 1d);\r\n\r\n        // ============ Equivalence Partitions Tests ==============\r\n\r\n        // TC01: Ray's line is outside the sphere (0 points)\r\n        assertNull(sphere.findIntersections(new Ray(new Point(-1, 0, 0), new Vector(1, 1, 0))),\r\n                   \"Ray's line out of sphere\");\r\n\r\n        // TC02: Ray starts before and crosses the sphere (2 points)\r\n        Point p1 = new Point(0.0651530771650466, 0.355051025721682, 0);\r\n        Point p2 = new Point(1.53484692283495, 0.844948974278318, 0);\r\n        List<Point> result = sphere.findIntersections(new Ray(new Point(-1, 0, 0),new Vector(3, 1, 0)));\r\n        assertEquals(2, result.size(), \"Wrong number of points\");\r\n        if (result.get(0).getX() > result.get(1).getX())\r\n            result = List.of(result.get(1), result.get(0));\r\n        assertEquals(List.of(p1, p2), result, \"Ray crosses sphere\");\r\n\r\n        // TC03: Ray starts inside the sphere (1 point)\r\n        \r\n        \r\n        ...\r\n        // TC04: Ray starts after the sphere (0 points)\r\n        ...\r\n\r\n        // =============== Boundary Values Tests ==================\r\n\r\n        // **** Group: Ray's line crosses the sphere (but not the center)\r\n        // TC11: Ray starts at sphere and goes inside (1 points)\r\n        // TC12: Ray starts at sphere and goes outside (0 points)\r\n\r\n        // **** Group: Ray's line goes through the center\r\n        // TC13: Ray starts before the sphere (2 points)\r\n        // TC14: Ray starts at sphere and goes inside (1 points)\r\n        // TC15: Ray starts inside (1 points)\r\n        // TC16: Ray starts at the center (1 points)\r\n        // TC17: Ray starts at sphere and goes outside (0 points)\r\n        // TC18: Ray starts after sphere (0 points)\r\n\r\n        // **** Group: Ray's line is tangent to the sphere (all tests 0 points)\r\n        // TC19: Ray starts before the tangent point\r\n        // TC20: Ray starts at the tangent point\r\n        // TC21: Ray starts after the tangent point\r\n\r\n        // **** Group: Special cases\r\n        // TC19: Ray's line is outside, ray is orthogonal to ray start to sphere's center line\r\n\r\n    }\r\n\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/unittests/geometries/SphereTests.java b/src/unittests/geometries/SphereTests.java
--- a/src/unittests/geometries/SphereTests.java	(revision ea628a76f7db129a3869b57256a7057ace2dc7ed)
+++ b/src/unittests/geometries/SphereTests.java	(date 1648468391774)
@@ -1,16 +1,13 @@
 /**
- * 
+ *
  */
 package unittests.geometries;
 import geometries.Sphere;
 import primitives.Point;
-import primitives.Ray;
 import primitives.Vector;
 
 import static org.junit.jupiter.api.Assertions.*;
 
-import java.util.List;
-
 import org.junit.jupiter.api.Test;
 
 /**
@@ -25,63 +22,10 @@
 	 */
 	@Test
 	void testGetNormal() {
-		 // ============ Equivalence Partitions Tests ==============
+		// ============ Equivalence Partitions Tests ==============
 		Sphere s = new Sphere(new Point(0,0,0), 1);
 		Vector n = new Vector(1,0,0);
 		// TC01: Test that the result of getNormal is proper
 		assertEquals(n, s.getNormal(new Point(1,0,0)), "Bad normal to sphere");
 	}
-	/**
-     * Test method for {@link geometries.Sphere#findIntersections(primitives.Ray)}.
-     */
-    @Test
-    public void testFindIntersections() {
-        Sphere sphere = new Sphere(new Point (1, 0, 0), 1d);
-
-        // ============ Equivalence Partitions Tests ==============
-
-        // TC01: Ray's line is outside the sphere (0 points)
-        assertNull(sphere.findIntersections(new Ray(new Point(-1, 0, 0), new Vector(1, 1, 0))),
-                   "Ray's line out of sphere");
-
-        // TC02: Ray starts before and crosses the sphere (2 points)
-        Point p1 = new Point(0.0651530771650466, 0.355051025721682, 0);
-        Point p2 = new Point(1.53484692283495, 0.844948974278318, 0);
-        List<Point> result = sphere.findIntersections(new Ray(new Point(-1, 0, 0),new Vector(3, 1, 0)));
-        assertEquals(2, result.size(), "Wrong number of points");
-        if (result.get(0).getX() > result.get(1).getX())
-            result = List.of(result.get(1), result.get(0));
-        assertEquals(List.of(p1, p2), result, "Ray crosses sphere");
-
-        // TC03: Ray starts inside the sphere (1 point)
-        
-        
-        ...
-        // TC04: Ray starts after the sphere (0 points)
-        ...
-
-        // =============== Boundary Values Tests ==================
-
-        // **** Group: Ray's line crosses the sphere (but not the center)
-        // TC11: Ray starts at sphere and goes inside (1 points)
-        // TC12: Ray starts at sphere and goes outside (0 points)
-
-        // **** Group: Ray's line goes through the center
-        // TC13: Ray starts before the sphere (2 points)
-        // TC14: Ray starts at sphere and goes inside (1 points)
-        // TC15: Ray starts inside (1 points)
-        // TC16: Ray starts at the center (1 points)
-        // TC17: Ray starts at sphere and goes outside (0 points)
-        // TC18: Ray starts after sphere (0 points)
-
-        // **** Group: Ray's line is tangent to the sphere (all tests 0 points)
-        // TC19: Ray starts before the tangent point
-        // TC20: Ray starts at the tangent point
-        // TC21: Ray starts after the tangent point
-
-        // **** Group: Special cases
-        // TC19: Ray's line is outside, ray is orthogonal to ray start to sphere's center line
-
-    }
-
 }
Index: src/unittests/geometries/TriangleTests.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>/**\r\n * \r\n */\r\npackage unittests.geometries;\r\n\r\nimport static org.junit.jupiter.api.Assertions.*;\r\n\r\nimport org.junit.jupiter.api.Test;\r\n\r\nimport geometries.Polygon;\r\nimport primitives.Point;\r\nimport primitives.Vector;\r\n\r\n/**\r\n * Unit tests for geometries.Triangle class\r\n * @author Shuva\r\n *\r\n */\r\nclass TriangleTests {\r\n\r\n\t@Test\r\n\tvoid test() {\r\n\t\t// ============ Equivalence Partitions Tests ==============\r\n\t\tPolygon pl = new Polygon(new Point(0, 0, 1), new Point(1, 0, 0), new Point(0, 1, 0), new Point(-1, 1, 1));\r\n\t\tdouble sqrt3 = Math.sqrt(1d / 3);\r\n\t\t// TC01: Test that the result of getNormal is proper\r\n\t\tassertEquals(new Vector(sqrt3, sqrt3, sqrt3), pl.getNormal(new Point(0, 0, 1)), \"Bad normal to trinagle\");\r\n\t\r\n\t}\r\n\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/unittests/geometries/TriangleTests.java b/src/unittests/geometries/TriangleTests.java
--- a/src/unittests/geometries/TriangleTests.java	(revision ea628a76f7db129a3869b57256a7057ace2dc7ed)
+++ b/src/unittests/geometries/TriangleTests.java	(date 1648406953868)
@@ -1,5 +1,5 @@
 /**
- * 
+ *
  */
 package unittests.geometries;
 
@@ -8,6 +8,7 @@
 import org.junit.jupiter.api.Test;
 
 import geometries.Polygon;
+import geometries.Triangle;
 import primitives.Point;
 import primitives.Vector;
 
@@ -25,7 +26,19 @@
 		double sqrt3 = Math.sqrt(1d / 3);
 		// TC01: Test that the result of getNormal is proper
 		assertEquals(new Vector(sqrt3, sqrt3, sqrt3), pl.getNormal(new Point(0, 0, 1)), "Bad normal to trinagle");
-	
+
+	}
+
+	/**
+	 * Test method for {@link geometries.Triangle#getNormal(primitives.Point)}.
+	 */
+	@Test
+	public void testGetNormal() {
+		// ============ Equivalence Partitions Tests ==============
+		// TC01: There is a simple single test here
+		Triangle pl = new Triangle(new Point(0, 0, 1), new Point(1, 0, 0), new Point(0, 1, 0));
+		double sqrt3 = Math.sqrt(1d / 3);
+		assertEquals(new Vector(sqrt3, sqrt3, sqrt3), pl.getNormal(new Point(0, 0, 1)), "Bad normal to trinagle");
 	}
 
 }
Index: src/unittests/geometries/TubeTests.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>/**\r\n * \r\n */\r\npackage unittests.geometries;\r\n\r\nimport static org.junit.jupiter.api.Assertions.*;\r\n\r\nimport org.junit.jupiter.api.Test;\r\n\r\nimport geometries.Plane;\r\nimport geometries.Tube;\r\nimport primitives.Point;\r\nimport primitives.Ray;\r\nimport primitives.Vector;\r\n\r\n/**\r\n * Unit tests for geometries.Tube class\r\n * @author Shuva\r\n *\r\n */\r\nclass TubeTests {\r\n\r\n\t/**\r\n\t * Test method for {@link geometries.Tube#getNormal(primitives.Point)}.\r\n\t */\r\n\t@Test\r\n\tvoid testGetNormal() {\r\n\t\t // ============ Equivalence Partitions Tests ==============\r\n\t\tTube t = new Tube(new Ray(new Point(0,0,0), new Vector(0,0,1)), 1);\r\n\t\tPoint p1 = new Point(1,0,1);\r\n\t\tVector n = new Vector(1,0,0);\r\n\t\t// TC01: Test that the result of getNormal is proper\r\n\t\tassertEquals(n, t.getNormal(p1), \"Bad normal to tube\");\r\n\t\tPoint p2 = new Point(1,0,0);\r\n\t\t\r\n\t\t// =============== Boundary Values Tests ==================\r\n        // TC10: The point is in front of the ray head\r\n\t\tassertThrows(IllegalArgumentException.class,\r\n\t\t\t\t() -> t.getNormal(p2), \"calculates normal when the point is in front of the ray head\");\r\n\t}\r\n\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/unittests/geometries/TubeTests.java b/src/unittests/geometries/TubeTests.java
--- a/src/unittests/geometries/TubeTests.java	(revision ea628a76f7db129a3869b57256a7057ace2dc7ed)
+++ b/src/unittests/geometries/TubeTests.java	(date 1648468392817)
@@ -1,5 +1,5 @@
 /**
- * 
+ *
  */
 package unittests.geometries;
 
@@ -25,16 +25,16 @@
 	 */
 	@Test
 	void testGetNormal() {
-		 // ============ Equivalence Partitions Tests ==============
+		// ============ Equivalence Partitions Tests ==============
 		Tube t = new Tube(new Ray(new Point(0,0,0), new Vector(0,0,1)), 1);
 		Point p1 = new Point(1,0,1);
 		Vector n = new Vector(1,0,0);
 		// TC01: Test that the result of getNormal is proper
 		assertEquals(n, t.getNormal(p1), "Bad normal to tube");
 		Point p2 = new Point(1,0,0);
-		
+
 		// =============== Boundary Values Tests ==================
-        // TC10: The point is in front of the ray head
+		// TC10: The point is in front of the ray head
 		assertThrows(IllegalArgumentException.class,
 				() -> t.getNormal(p2), "calculates normal when the point is in front of the ray head");
 	}
Index: ISE5782_1011_2958.iml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/ISE5782_1011_2958.iml b/ISE5782_1011_2958.iml
new file mode 100644
--- /dev/null	(date 1648394339253)
+++ b/ISE5782_1011_2958.iml	(date 1648394339253)
@@ -0,0 +1,21 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<module type="JAVA_MODULE" version="4">
+  <component name="NewModuleRootManager">
+    <output url="file://$MODULE_DIR$/bin" />
+    <exclude-output />
+    <content url="file://$MODULE_DIR$">
+      <sourceFolder url="file://$MODULE_DIR$/src" isTestSource="false" />
+    </content>
+    <orderEntry type="jdk" jdkName="JavaSE-17" jdkType="JavaSDK" />
+    <orderEntry type="sourceFolder" forTests="false" />
+    <orderEntry type="module-library">
+      <library name="junit5">
+        <CLASSES>
+          <root url="jar://$APPLICATION_HOME_DIR$/lib/junit.jar!/" />
+        </CLASSES>
+        <JAVADOC />
+        <SOURCES />
+      </library>
+    </orderEntry>
+  </component>
+</module>
\ No newline at end of file
Index: src/geometries/Polygon.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package geometries;\r\n\r\nimport java.util.List;\r\n\r\nimport primitives.*;\r\nimport static primitives.Util.*;\r\n\r\n/**\r\n * Polygon class represents two-dimensional polygon in 3D Cartesian coordinate\r\n * system\r\n * \r\n * @author Dan\r\n */\r\npublic class Polygon implements Geometry {\r\n\t/**\r\n\t * List of polygon's vertices\r\n\t */\r\n\tprotected List<Point> vertices;\r\n\t/**\r\n\t * Associated plane in which the polygon lays\r\n\t */\r\n\tprotected Plane plane;\r\n\tprivate int size;\r\n\r\n\t/**\r\n\t * Polygon constructor based on vertices list. The list must be ordered by edge\r\n\t * path. The polygon must be convex.\r\n\t * \r\n\t * @param vertices list of vertices according to their order by edge path\r\n\t * @throws IllegalArgumentException in any case of illegal combination of\r\n\t *                                  vertices:\r\n\t *                                  <ul>\r\n\t *                                  <li>Less than 3 vertices</li>\r\n\t *                                  <li>Consequent vertices are in the same\r\n\t *                                  point\r\n\t *                                  <li>The vertices are not in the same\r\n\t *                                  plane</li>\r\n\t *                                  <li>The order of vertices is not according\r\n\t *                                  to edge path</li>\r\n\t *                                  <li>Three consequent vertices lay in the\r\n\t *                                  same line (180&#176; angle between two\r\n\t *                                  consequent edges)\r\n\t *                                  <li>The polygon is concave (not convex)</li>\r\n\t *                                  </ul>\r\n\t *                                  \r\n\t */\r\n\tpublic Polygon(Point... vertices) {\r\n\t\tif (vertices.length < 3)\r\n\t\t\tthrow new IllegalArgumentException(\"A polygon can't have less than 3 vertices\");\r\n\t\tthis.vertices = List.of(vertices);\r\n\t\t// Generate the plane according to the first three vertices and associate the\r\n\t\t// polygon with this plane.\r\n\t\t// The plane holds the invariant normal (orthogonal unit) vector to the polygon\r\n\t\tplane = new Plane(vertices[0], vertices[1], vertices[2]);\r\n\t\tif (vertices.length == 3)\r\n\t\t\treturn; // no need for more tests for a Triangle\r\n\t\tVector n = plane.getNormal(); \r\n\r\n\t\t// Subtracting any subsequent points will throw an IllegalArgumentException\r\n\t\t// because of Zero Vector if they are in the same point\r\n\t\tVector edge1 = vertices[vertices.length - 1].subtract(vertices[vertices.length - 2]);\r\n\t\tVector edge2 = vertices[0].subtract(vertices[vertices.length - 1]);\r\n\r\n\t\t// Cross Product of any subsequent edges will throw an IllegalArgumentException\r\n\t\t// because of Zero Vector if they connect three vertices that lay in the same\r\n\t\t// line.\r\n\t\t// Generate the direction of the polygon according to the angle between last and\r\n\t\t// first edge being less than 180 deg. It is hold by the sign of its dot product\r\n\t\t// with\r\n\t\t// the normal. If all the rest consequent edges will generate the same sign -\r\n\t\t// the\r\n\t\t// polygon is convex (\"kamur\" in Hebrew).\r\n\t\tboolean positive = edge1.crossProduct(edge2).dotProduct(n) > 0;\r\n\t\tfor (var i = 1; i < vertices.length; ++i) {\r\n\t\t\t// Test that the point is in the same plane as calculated originally\r\n\t\t\tif (!isZero(vertices[i].subtract(vertices[0]).dotProduct(n)))\r\n\t\t\t\tthrow new IllegalArgumentException(\"All vertices of a polygon must lay in the same plane\");\r\n\t\t\t// Test the consequent edges have\r\n\t\t\tedge1 = edge2;\r\n\t\t\tedge2 = vertices[i].subtract(vertices[i - 1]);\r\n\t\t\tif (positive != (edge1.crossProduct(edge2).dotProduct(n) > 0))\r\n\t\t\t\tthrow new IllegalArgumentException(\"All vertices must be ordered and the polygon must be convex\");\r\n\t\t}\r\n\t\tsize = vertices.length;\r\n\t}\r\n\r\n\t@Override\r\n\tpublic Vector getNormal(Point point) {\r\n\t\treturn plane.getNormal();\r\n\t}\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/geometries/Polygon.java b/src/geometries/Polygon.java
--- a/src/geometries/Polygon.java	(revision ea628a76f7db129a3869b57256a7057ace2dc7ed)
+++ b/src/geometries/Polygon.java	(date 1648394339263)
@@ -8,7 +8,7 @@
 /**
  * Polygon class represents two-dimensional polygon in 3D Cartesian coordinate
  * system
- * 
+ *
  * @author Dan
  */
 public class Polygon implements Geometry {
@@ -25,7 +25,7 @@
 	/**
 	 * Polygon constructor based on vertices list. The list must be ordered by edge
 	 * path. The polygon must be convex.
-	 * 
+	 *
 	 * @param vertices list of vertices according to their order by edge path
 	 * @throws IllegalArgumentException in any case of illegal combination of
 	 *                                  vertices:
@@ -42,7 +42,7 @@
 	 *                                  consequent edges)
 	 *                                  <li>The polygon is concave (not convex)</li>
 	 *                                  </ul>
-	 *                                  
+	 *
 	 */
 	public Polygon(Point... vertices) {
 		if (vertices.length < 3)
@@ -54,7 +54,7 @@
 		plane = new Plane(vertices[0], vertices[1], vertices[2]);
 		if (vertices.length == 3)
 			return; // no need for more tests for a Triangle
-		Vector n = plane.getNormal(); 
+		Vector n = plane.getNormal();
 
 		// Subtracting any subsequent points will throw an IllegalArgumentException
 		// because of Zero Vector if they are in the same point
Index: src/geometries/Plane.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package geometries;\r\nimport java.util.List;\r\n\r\nimport primitives.*;\r\n/**\r\n * Plane (point and vector)\r\n *\r\n */\r\npublic class Plane implements Geometry {\r\n\tprivate Point q0;\r\n\tprivate Vector normal;\r\n\t/**\r\n\t * Constructor\r\n\t * @param p1\r\n\t * @param p2\r\n\t * @param p3\r\n\t * Calculate the normal to the plane formed by the 3 points obtained\r\n\t */\r\n\tpublic Plane (Point p1, Point p2, Point p3)\r\n\t{\r\n\t\tq0 = p1;\r\n\t\tVector v1 = p2.subtract(p1);\r\n\t\tVector v2 = p3.subtract(p1);\r\n\t\tnormal = v1.crossProduct(v2).normalize();\r\n\t}\r\n\t/**\r\n\t * Constructor\r\n\t * @param p\r\n\t * @param v\r\n\t */\r\n\tpublic Plane (Point p, Vector v)\r\n\t{\r\n\t\tq0 = p;\r\n\t\tnormal = new Vector(v.getXyz());\r\n\t}\r\n\t/**\r\n\t * Calculates the normalized normal to the plane - the value of the field normal\r\n\t * @return\r\n\t */\r\n\tpublic Vector getNormal(Point p)\r\n\t{\r\n\t\treturn normal;\r\n\t\t\r\n\t}\r\n\t/**\r\n\t * Returns the value of the field normal\r\n\t * @return\r\n\t */\r\n\tpublic Vector getNormal()\r\n\t{\r\n\t\treturn normal;\r\n\t}\r\n\tpublic List<Point> findIntsersections(Ray ray)\r\n\t{\r\n\t\t\r\n\t}\r\n\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/geometries/Plane.java b/src/geometries/Plane.java
--- a/src/geometries/Plane.java	(revision ea628a76f7db129a3869b57256a7057ace2dc7ed)
+++ b/src/geometries/Plane.java	(date 1648394339199)
@@ -40,7 +40,7 @@
 	public Vector getNormal(Point p)
 	{
 		return normal;
-		
+
 	}
 	/**
 	 * Returns the value of the field normal
Index: src/geometries/Geometry.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package geometries;\r\nimport primitives.*;\r\n\r\npublic interface Geometry extends Intersectable {\r\n\tpublic Vector getNormal(Point p);\r\n\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/geometries/Geometry.java b/src/geometries/Geometry.java
--- a/src/geometries/Geometry.java	(revision ea628a76f7db129a3869b57256a7057ace2dc7ed)
+++ b/src/geometries/Geometry.java	(date 1648468389633)
@@ -1,7 +1,8 @@
 package geometries;
 import primitives.*;
 
-public interface Geometry extends Intersectable {
+public interface Geometry
+{
 	public Vector getNormal(Point p);
 
 }
